# -*- coding: utf-8 -*-
"""Flask.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_fLMcxzGwtog6u2UCG03vKKlu7RFFexx
"""

# Install dependencies
!pip install Flask==3.0.0 pyngrok==7.1.2
!pip install dash
!pip install keplergl

# Import libs
from pyngrok import ngrok
import shutil
from IPython.display import Javascript

# Get Data from Github
!git clone https://github.com/jpti89/AB-Wildfires.git
!mkdir "./template/"
!cp /content/AB-Wildfires/template/kepler_load.html /content/template/
!cp /content/AB-Wildfires/template/notdash2.html /content/template/

# Setup ngrok web link
ngrok_key = "2ekHpFtjQMnrMKcsP6FGspAHvSa_3wdrw4jEhBTX5yzRbo5m1"
port = 5000
ngrok.set_auth_token(ngrok_key)
ngrok.connect(port).public_url

# Open Webpage
def open_web():
    url = ngrok.connect(port).public_url
    display(Javascript('window.open("{url}");'.format(url=url)))
open_web()

# Import libs
from flask import Flask, config, render_template, request
import plotly
import plotly.express as px
import plotly.graph_objects as go
from keplergl import KeplerGl
import pandas as pd
import json
import numpy as np

# Setup Flask app
app = Flask(__name__, template_folder='/content/template')

#Open Data files
with open('./AB-Wildfires/Data/alberta_788.geojson', 'r') as f:
  boundaries = f.read()

with open('./AB-Wildfires/Data/fp-historical-wildfire-data-2006-2021(2)(1).csv', 'r') as f2:
  historical_fire = f2.read()

with open('./AB-Wildfires/Data/predictions.csv', 'r') as f3:
  predictions = f3.read()

df = pd.read_csv("./AB-Wildfires/Data/fp-historical-wildfire-data-2006-2021(2)(1).csv")

#KeplerGL min config and setup layers
config = {
    'version': 'v1',
    'config': {
        'mapState': {
            'latitude': 54.1356608,
            'longitude': -112.6357456,
            'zoom': 4
        }
    }
}
map_1 = KeplerGl(config=config)
map_1.add_data(data=predictions, name='geojson_predictions')
map_1.add_data(data=historical_fire, name='geojson_historical_fire')
map_1.add_data(data=boundaries, name='geojson_boundries')

# Flask Root page
@app.route("/")
def hello():
  return render_template('/kepler_load.html')

@app.route('/empty_map')
def empty_map():
    return map_1._repr_html_()

#Flask Year visualization
@app.route('/chart1')
def chart1():
    fig = go.Figure()
    fig.add_trace(go.Bar(x = np.sort(df.fire_year.unique()),
                    y = df['fire_year'].groupby([df.fire_year]).agg('count'),
                    name='Year of the wildfire',
                    marker_color='rgb(55, 83, 109)'
                    ))

    fig.update_layout(
        title='Wildfires per year from 2006 to 2021',
        xaxis_tickfont_size=14,
        yaxis=dict(
            title='Count',
            titlefont_size=16,
            tickfont_size=14,
        ),
        xaxis=dict(
            title='Year',
            tickmode='linear'),
        legend=dict(
            x=0,
            y=1.0,
            bgcolor='rgba(255, 255, 255, 0)',
            bordercolor='rgba(255, 255, 255, 0)'
        ),
        bargap=0.15, # gap between bars of adjacent location coordinates.
        bargroupgap=0.1 # gap between bars of the same location coordinate.
    )
    graphJSON = json.dumps(fig, cls=plotly.utils.PlotlyJSONEncoder)
    header="Wildfires per year"
    description = """
    We can visualize a downtrend in number of fires between the years 2006 and 2021.
    """
    return render_template('/notdash2.html', graphJSON=graphJSON, header=header,description=description)

#Flask size visualization
@app.route('/chart2')
def chart2():
    fig = px.pie(df['size_class'].groupby([df.size_class]).agg('count'), values='size_class', names=np.sort(df.size_class.unique()))
    fig.update_layout(
        title='Size class of the wildfire')

    graphJSON = json.dumps(fig, cls=plotly.utils.PlotlyJSONEncoder)
    header="Size of Wildfires"
    description = """
    The size breakdown is as follows:
    A class = 0 to 0.1 ha
    B class > 0.1 ha to 4.0 ha
    C class > 4.0 ha to 40.0 ha
    D class > 40.0 ha to 200 ha
    E class > 200 ha
    """
    return render_template('/notdash2.html', graphJSON=graphJSON, header=header,description=description)

#Flask Origin visualization
@app.route('/chart3')
def chart3():
    fig = go.Figure()
    fig.add_trace(go.Bar(x = np.sort(df.general_cause_desc.unique()),
                y = df['general_cause_desc'].groupby([df.general_cause_desc]).agg('count'),
                name='Year of the wildfire',
                marker_color='rgb(55, 83, 109)'
                ))

    fig.update_layout(
    title='Cause of origin of Wildfires',
    xaxis_tickfont_size=14,
    yaxis=dict(
        title='Count',
        titlefont_size=16,
        tickfont_size=14,
    ),
    legend=dict(
        x=0,
        y=1.0,
        bgcolor='rgba(255, 255, 255, 0)',
        bordercolor='rgba(255, 255, 255, 0)'
    ),
    bargap=0.15, # gap between bars of adjacent location coordinates.
    bargroupgap=0.1 # gap between bars of the same location coordinate.
    )
    graphJSON = json.dumps(fig, cls=plotly.utils.PlotlyJSONEncoder)
    header="Cause of Origin"
    description = """
    We can see that the great moyority of Wildfires are caused by Lighting, follow by recreation (Camper, hunter) and residents.
    """
    return render_template('/notdash2.html', graphJSON=graphJSON, header=header,description=description)

#Flask Humidity visualization
@app.route('/chart4')
def chart4():
    fig = px.histogram(df, x='relative_humidity', nbins=20)
    fig.update_layout(
    title='Humidity at the start of Wildfire',
    xaxis_tickfont_size=14,
    yaxis=dict(
        title='Count',
        titlefont_size=16,
        tickfont_size=14,
    ),
    legend=dict(
        x=0,
        y=1.0,
        bgcolor='rgba(255, 255, 255, 0)',
        bordercolor='rgba(255, 255, 255, 0)'
    )
  )
    graphJSON = json.dumps(fig, cls=plotly.utils.PlotlyJSONEncoder)
    header="Humidity"
    description = """
    """
    return render_template('/notdash2.html', graphJSON=graphJSON, header=header,description=description)

#Flask Temperature visualization
@app.route('/chart5')
def chart5():
    fig = px.histogram(df, x='temperature', nbins=20)
    fig.update_layout(
    title='Temperature at the start of Wildfire',
    xaxis_tickfont_size=14,
    yaxis=dict(
        title='Count',
        titlefont_size=16,
        tickfont_size=14,
    ),
    legend=dict(
        x=0,
        y=1.0,
        bgcolor='rgba(255, 255, 255, 0)',
        bordercolor='rgba(255, 255, 255, 0)'
    )
    )
    graphJSON = json.dumps(fig, cls=plotly.utils.PlotlyJSONEncoder)
    header="Temperature"
    description = """
    """
    return render_template('/notdash2.html', graphJSON=graphJSON, header=header,description=description)

if __name__ == '__main__':
    app.run(port = port)

import csv
import random
from datetime import datetime
from collections import defaultdict

from flask import Flask, render_template, request, jsonify

app = Flask(_name_)

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/data')
def get_data():
    with open('/content/filtered_data.csv', 'r') as file:
        csv_reader = csv.DictReader(file)
        data = list(csv_reader)
    return jsonify(data)

@app.route('/visualizations', methods=['POST'])
def update_visualizations():
    selected_year = request.json['selectedYear']
    selected_fire_origin = request.json['selectedFireOrigin']

    with open('filtered_data.csv', 'r') as file:
        csv_reader = csv.DictReader(file)
        data = list(csv_reader)

    # Filter data based on selected year
    filtered_data = [d for d in data if datetime.strptime(d['fire_start_date'], '%Y-%m-%d').year == int(selected_year)]

    # Create scatter plot for wind speed against wind direction colored by month
    wind_direction_vs_speed_data = []
    for d in filtered_data:
        wind_direction_vs_speed_data.append({
            'x': int(d['wind_direction']),
            'y': int(d['wind_speed']),
            'color': random.choice(['red', 'green', 'blue', 'yellow']),
            'text': f"Wind Direction: {d['wind_direction']}, Wind Speed: {d['wind_speed']}, General Cause: {d['general_cause_desc']}"
        })

    # Calculate percentage distribution of general causes
    general_cause_distribution = defaultdict(int)
    total_occurrences = len(filtered_data)
    for d in filtered_data:
        general_cause_distribution[d['general_cause_desc']] += 1

    general_cause_distribution_percent = {k: round(v / total_occurrences * 100, 2) for k, v in general_cause_distribution.items()}

    # Calculate percentage distribution of activity classes within selected general cause
    activity_class_distribution = defaultdict(int)
    selected_general_cause_data = [d for d in filtered_data if d['general_cause_desc'] == selected_fire_origin]
    total_selected_occurrences = len(selected_general_cause_data)
    for d in selected_general_cause_data:
        activity_class_distribution[d['activity_class']] += 1

    activity_class_distribution_percent = {k: round(v / total_selected_occurrences * 100, 2) for k, v in activity_class_distribution.items()}

    # Calculate frequency of fire origins for each month
    fire_origin_distribution = defaultdict(list)
    for d in selected_general_cause_data:
        month = datetime.strptime(d['fire_start_date'], '%Y-%m-%d').month
        fire_origin_distribution[d['fire_origin']].append(month)

    # Prepare data for the bar chart
    months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
    bar_chart_data = {fire_origin: [fire_origin_distribution[fire_origin].count(month) for month in range(1, 13)] for fire_origin in fire_origin_distribution}

    response_data = {
        'windDirectionVsSpeedData': wind_direction_vs_speed_data,
        'generalCauseDistribution': general_cause_distribution_percent,
        'activityClassDistribution': activity_class_distribution_percent,
        'fireOriginDistribution': bar_chart_data
    }

    return jsonify(response_data)

@app.route('/fire_origins')
def get_fire_origins():
    with open('/content/drive/My Drive/filtered_data.csv', 'r') as file:
        csv_reader = csv.DictReader(file)
        data = list(csv_reader)

    fire_origins = set()
    for d in data:
        fire_origins.add(d['fire_origin'])

    return jsonify(list(fire_origins))

@app.route('/line_chart')
def get_line_chart_data():
    selected_fire_origin = request.args.get('selectedFireOrigin')

    with open('filtered_data.csv', 'r') as file:
        csv_reader = csv.DictReader(file)
        data = list(csv_reader)

    filtered_data = [d for d in data if d['fire_origin'] == selected_fire_origin]

    humidity_data = []
    temperature_data = []
    wind_speed_data = []
    for d in filtered_data:
        humidity_data.append({'x': d['fire_start_date'], 'y': float(d['humidity'])})
        temperature_data.append({'x': d['fire_start_date'], 'y': float(d['temperature'])})
        wind_speed_data.append({'x': d['fire_start_date'], 'y': float(d['wind_speed'])})

    line_chart_data = {
        'humidityData': humidity_data,
        'temperatureData': temperature_data,
        'windSpeedData': wind_speed_data
    }

    return jsonify(line_chart_data)

if _name_ == '_main_':
    from pyngrok import ngrok

    # Start ngrok tunnel to expose Flask app
    public_url = ngrok.connect(port=5000)
    print(' * ngrok tunnel:', public_url)


    # Run Flask app
    app.run()